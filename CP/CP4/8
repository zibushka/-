#include <stdio.h>
#include <math.h>

// Функция, данная в задании
long double func ( long double x ) { 
	return 3 * log(x) * log(x) + 6 * log(x) - 5; 
}

// Производная функции, данной в задании
long double dif_func (long double x) {
	return 6 * log(x) / x + 6 / x;
}

// Вторая производная функции, данной в задании
long double dif_dif_func (long double x) {
	return -6 * log(x) / x / x;
}

// Функция модуль
long double my_abs( long double x) {
	if ( x < 0 ) {
		return -x;
	}
	return x;
}

int main() {
    long double eps = 1.0l, a = 1.0l, b = 2.0l, x, x1 = 0;
    
    // Вычисление машинного эпсилона
    while (1.0l + eps / 2.0l > 1.0l) { 
    	eps /= 2.0l;
    }
    
    // Изначальное эпсилон слишком маленькое. Поэтому, в вычисление происходит зацикливание. Можно чуть - чуть увеличить эпсилон, и метод Ньютона будет работать.
    eps *= 50;
    
    printf("Машинное эпсилон для типа double = %.16Le\n", eps);
    
    // Проверка на сходимость
    // Для этого проходимся циклом от левой границе к правой, с шагом 1/1000000, проверяя, выполнение условие сходимости |F(x) * F''(x)| < (F'(x))^2, если условие не выполнятеся, мы завершаем программу
    for (long long i = 1000000; i <= 2000000; i++ ) {
    	x = i / 1000000.0l;
    	if (my_abs(func(x) * dif_dif_func(x)) - dif_func(x) * dif_func(x) >= eps) {
    		printf("Невозможно вычислить значение методом Ньютона, метод не сходится.\n");
    		return 0;
    	}
    }
    
    // Изначально, х равен середине отрезка
    x = (a + b) / 2;
    
    // Вычисление корня
    while (my_abs(x - x1) >= eps) {
    	x1 = x;
    	x = x1 - func(x) / dif_func(x);
    }
	
	// Вывод ответа
	printf("Приближенное значение корня, полученного при помощи метода Ньютона равно: %Le\n", x);
}
